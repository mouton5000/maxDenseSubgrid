\section{An instance with an $O(\sqrt{n})$ gap between the worst and the best solution.}

\label{apx:badinstance}


Theorem~\ref{theo:sqrtnapprox} of Section~\ref{sect:approx} proves a default $2\sqrt{n}$ upper bound of the approximation ratio for every algorithm returning a maximal solution.

We give, in this appendix, in Figure~\ref{fig:badExample}, an instance in which the ratio between an optimal density and the lowest density of a maximal solution is $O(\sqrt{n})$. This instance contains a square of $r \times r$ blue ones (in Figure~\ref{fig:badExample}, $r = 4$) and two diagonal lines of $r$ red ones and $r$ green ones. Note that, as $r$ approaches infinity, $r^2$ is asymptotically equivalent to $n$. An optimal solution, given in Figure~\ref{fig:badexampleGood}, consists in maximally contracting the blue square. In that case, most of the blue ones have 8 neighbors (the maximum number of neighbor an entry can have in the matrix). The density of this matrix is $O(r^2) = O(n)$. On the contrary, an algorithm which contracts the lines containing the green ones and the columns containing the red ones would obtain the matrix in Figure~\ref{fig:badExampleBad}. In this matrix, no line or column can be contracted and most of the blue ones have no neighbor. The density is $O(r) = O(\sqrt{n})$. 

\input{approx_bad_instance}
\input{approx_bad_instance_good}
\input{approx_bad_instance_bad}



Note that this is not a hard instance for the greedy algorithm, the neighborization algorithm or the LCL algorithm to this instance as the density of the resulting matrix of each algorithm is $O(n)$. Indeed, the greedy algorithm and the neighborization contract the blue square first. The LCL algorithm either contracts all the lines of the matrix or contracts all the columns: every blue one has at least one neighbor and the density is $O(r^2)$. However, for each algorithm, we can adapt this instance such that the density returned by this algorithm is $O(\sqrt{n})$. Each of the following subsections is dedicated to an algorithm and its adapted instance. 

\subsection{Adaptation to the greedy algorithm}

In Figure~\ref{fig:greedyExample}, we give an instance adapted from the instance of Figure~\ref{fig:badExample}. This instance contains, from coordinates (1,1) to (11,11), is the square of blue 1. An optimal solution is obtained by fully contracting this square. To do so, we have to contract lines and columns 2, 4, 6, 8 and 10 (the blue lines and columns). This is illustrated with Figure~\ref{fig:greedyExampleGood}. The worst maximal solution is obtained by not contracting it. This instance contains also 4 groups of ones in the last 6 columns and the last 6 lines (the green 1). We can increase the density of the matrix by contracting lines 13 and 16 and by contracting columns 13 and 16 (the green lines and columns). However, due to the red 1, it is not allowed to contract all the green lines and columns \textbf{and} all the blue lines and columns. A consequence is that we can either contract all the green 1 or contract all the red 1 (or a part of each). Finally, note that it in not allowed to contract any other line or column.

What does columns or lines the greedy algorithm contract in this instance? The algorithm search for the line or the column such that the contraction of that line or column maximally increases the density of the matrix. It appears that contracting any green line or column increases the density by 10 and that contracting any blue line or column increased the density by 7. Thus, the greedy algorithm chooses one of the green lines or columns and starts again. The same phenomenon occurs in the resulting matrix : an increase of 7 with the blue lines and columns and an increase of 10 with the left green lines and columns. The algorithm then always choose a green line or column until the solution is maximal. The returned solution is given in Figure~\ref{fig:greedyExampleBad}.



\renewcommand{\gridsize}{0.5}
\input{approx_bad_instanceGreedy}
\input{approx_bad_instanceGreedy_good}
\input{approx_bad_instanceGreedy_bad}

\subsection{Adaptation to the neighborization algorithm}

In Figure~\ref{fig:neighborizationExample}, we give an instance adapted from the instance of Figure~\ref{fig:badExample}. This instance contains, from coordinates (1,1) to (11,11), is the square of blue 1. An optimal solution is obtained by fully contracting this square. To do so, we have to contract lines and columns 2, 4, 6, 8 and 10 (the blue lines and columns). This is illustrated with Figure~\ref{fig:neighborizationExampleGood}. The worst maximal solution is obtained by not contracting it. This instance contains also 4 groups of ones in the last 6 columns and the last 6 lines (the green 1). We can increase the density of the matrix by contracting lines 13,14,15 and 18,19 and by contracting columns 13,14,15 and 18,19 (the green lines and columns). However, due to the red 1, it is not allowed to contract all the green lines and columns \textbf{and} all the blue lines and columns. A consequence is that we can either contract all the green 1 or contract all the red 1 (or a part of each). Finally, note that it in not allowed to contract any other line or column.

What does columns or lines the neighborization algorithm contract in this instance? The algorithm search for the line or the column such that the contraction of that line or column minimally decreases the number of pairs of 1 that can become neighbors. It appears that contracting any green line or column decreases this number by 17 or 18. On the other hand, contracting a blue line or column decreases this number by 20. Thus, the neighborization algorithm chooses one of the green lines or columns and starts again. The same phenomenon occurs in the resulting matrix : an decrease of 20 with the blue lines and columns and an increase of 17 or 18 with the left green lines and columns. The algorithm then always choose a green line or column until the solution is maximal. The returned solution is given in Figure~\ref{fig:neighborizationExample}.


\renewcommand{\gridsize}{0.5}
\input{approx_bad_instanceNeigh}
\input{approx_bad_instanceNeigh_good}
\input{approx_bad_instanceNeigh_bad}

\subsection{Adaptation to the LCL algorithm}
\renewcommand{\gridsize}{0.35}

In Figure~\ref{fig:lclExample}, we give an instance adapted from the instance of Figure~\ref{fig:badExample}.

\input{approx_bad_instanceLCL}
\input{approx_bad_instanceLCL_good}
\input{approx_bad_instanceLCL_bad}

\section{Discussion}

We highly believe this instance is the worst case that can happen and that the density of a maximal solution is always higher than $4\sqrt{n}$. The result of Theorem~\ref{theo:sqrtnapprox} may then possibly be updated to the following conjecture. 

\begin{conjecture}
	An algorithm returning any maximal solution of an instance of MMC is a $\sqrt{n}$-approximation.
\end{conjecture}